For this project, we implemented a secure communication protocol on top of our existing reliable transport layer from Project 1. We created a client and server that follow a handshake process using TLV-formatted messages, including Client Hello, Server Hello, and Finished. After the handshake, we encrypted and authenticated all data using AES-256-CBC and HMAC-SHA256, as described in the spec. We used a clear state machine (state_sec) to manage the handshake and data phases. The TLV message construction was handled using the provided helper functions, which made serialization and nesting easier. We used the transcript buffer to collect serialized handshake messages for use in both key derivation and integrity verification. For encryption and MAC, we created separate TLVs for the IV, ciphertext, and HMAC, and then wrapped them in a DATA TLV for transmission.

We passed the initial compilation and handshake structure tests quite easily (as we completed the tasks in the order of completing the handshakes then tackling the encryption/decryption), however we encountered issues where the client was not sending enough data or sent malformed TLVs due to incorrect ciphertext lengths or missing values. BAD MAC cases would cause the server to reject our message and exit early, which made debugging harder. Additionally we ran into a problem where output_sec() would net us 70/90 with us only getting 5/15 in the test cases Encrypt and MAC: Client and Encrypt and MAC: Server. Strangely enough, we would drop to 40/90 if our input_sec() wasn't commented out.

To solve this we realized we needed to serialize the data correctly in the buffer as we misplaced a singular variable value (hence the ssize_t len = serialize_tlv(buf, data_tlv);). We also used print_tlv_bytes() for debugging malformed TLVs. We went from getting partial credit (5/15) on both encryption tests to correctly encrypting and decrypting data. To solve the BAD MAC cases (which was the last bit of our points we were missing), we realized that we weren't authenticating the same bytes that we verified. This unfortunately took us a while to debug but we got it in time!

